//
//  LoginPresenter.swift
//  Sift
//
//  Created Денис Фролов on 25/01/2019.
//  Copyright © 2019 Denis Frolov. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import AWSMobileClient

class LoginPresenter {

    weak private var view: LoginViewProtocol!
    var interactor: LoginInteractorInputProtocol!
    private let router: LoginWireframeProtocol

    init(interface: LoginViewProtocol, interactor: LoginInteractorInputProtocol?, router: LoginWireframeProtocol) {
        self.view = interface
        self.interactor = interactor
        self.router = router
    }
    
    // MARK: - Amazon
    // test3
    // QQqq11!!
    func login(username: String, password: String) {
        AWSMobileClient.sharedInstance().signIn(username: username, password: password) { (signInResult, error) in
            if let error = error  {
                DispatchQueue.main.async {
                    self.router.showAlert(title: "Error", msg: error.localizedDescription)
                }
            } else if let signInResult = signInResult {
                switch (signInResult.signInState) {
                case .signedIn:
                    DispatchQueue.main.async {
                        TestViewController.presentBaseTestViewController()
                    }
                    print("User is signed in.")
                case .smsMFA:
                    DispatchQueue.main.async {
                        self.router.showAlert(title: nil, msg: "SMS message sent to \(signInResult.codeDetails!.destination!)")
                    }
                default:
                    print("Sign In needs info which is not et supported.")
                }
            }
        }
    }
    
    func login(phone: String) {
//        AWSMobileClient.sharedInstance()
    }
    
    private func confirmLogin(code: String) {
        
        AWSMobileClient.sharedInstance().confirmSignIn(challengeResponse: code) { (signInResult, error) in
            if let error = error  {
                DispatchQueue.main.async {
                    self.router.showAlert(title: "Error", msg: error.localizedDescription)
                }
            } else if let signInResult = signInResult {
                switch (signInResult.signInState) {
                case .signedIn:
                    DispatchQueue.main.async {
                        TestViewController.presentBaseTestViewController()
                    }
                    print("User is signed in.")
                default:
                    print("\(signInResult.signInState.rawValue)")
                }
            }
        }
    }
    
    private func showConfirmAlert(msg: String) {
        let alert = UIAlertController(title: nil, message: msg, preferredStyle: .alert)
        alert.addTextField { (textField) in
            textField.placeholder = "Code"
            textField.keyboardType = .numberPad
        }
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel, handler: nil))
        alert.addAction(UIAlertAction(title: "Confirm", style: .default, handler: { (action) in
            guard let codeTextField = alert.textFields?.first else { return }
            self.confirmLogin(code: codeTextField.text ?? "")
        }))
        (self.view as! UIViewController).present(alert, animated: true, completion: nil)
    }

}

// MARK: - LoginPresenterProtocol

extension LoginPresenter: LoginPresenterProtocol {
    
    // Actions
    
    func loginAction(phone: String?) {
        guard let phone = phone, !phone.isEmpty else {
            router.showAlert(title: "Error", msg: "Please enter your phone")
            return
        }
        login(phone: phone)
    }
    
    func loginAction(email: String?, password: String?) {
        guard let email = email, let password = password else {
            router.showAlert(title: "Error", msg: "Please enter your name and password")
            return
        }
        login(username: email, password: password)
    }
}

// MARK: - LoginInteractorOutputProtocol

extension LoginPresenter: LoginInteractorOutputProtocol {
    
}
